{
  parserClass="org.nixos.idea.lang.NixParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nix"
  psiImplClassSuffix="Impl"
  psiPackage="org.nixos.idea.psi"
  psiImplPackage="org.nixos.idea.psi.impl"

  elementTypeHolderClass="org.nixos.idea.psi.NixTypes"
  elementTypeClass="org.nixos.idea.psi.NixElementType"
  tokenTypeClass="org.nixos.idea.psi.NixTokenType"

  tokens = [
    // This list does not contain all tokens. This list only defines the debug
    // names for tokens which have a distinct text representation. Other tokens
    // are implicitly declared through their usage.
    IF = 'if'
    THEN = 'then'
    ELSE = 'else'
    ASSERT = 'assert'
    WITH = 'with'
    LET = 'let'
    IN = 'in'
    REC = 'rec'
    INHERIT = 'inherit'
    OR_KW = 'or'
    ELLIPSIS = '...'

    ASSIGN = '='
    COLON = ':'
    SEMI = ';'
    COMMA = ','
    AT = '@'
    LPAREN = '('
    RPAREN = ')'
    LCURLY = '{'
    RCURLY = '}'
    LBRAC = '['
    RBRAC = ']'
    DOLLAR_CURLY = '${'

    DOT = '.'
    HAS = '?'
    NOT = '!'
    TIMES = '*'
    DIVIDE = '/'
    PLUS = '+'
    MINUS = '-'
    LT = '<'
    GT = '>'
    CONCAT = '++'
    UPDATE = '//'
    LEQ = '<='
    GEQ = '>='
    EQ = '=='
    NEQ = '!='
    AND = '&&'
    OR = '||'
    IMPL = '->'

    // This two tokens must be declared here because they are not used by the
    // parser and therefore not declared anywhere else in the file.
    SCOMMENT = 'SCOMMENT'
    MCOMMENT = 'MCOMMENT'
  ]
}

nixFile ::= expr

;{ extends("expr_.*")=expr }
expr ::=
    expr_assert
  | expr_if
  | expr_let
  | expr_with
  | expr_lambda
  | expr_op

expr_assert ::= ASSERT expr SEMI expr
expr_if ::= IF expr THEN expr ELSE expr
expr_let ::= LET bind* IN expr
expr_with ::= WITH expr SEMI expr

expr_lambda ::= lambda_params COLON expr
private lambda_params ::= ID [ AT param_set ] | param_set [ AT ID ]
param_set ::= LCURLY [ ( param COMMA )* ( ELLIPSIS | param ) ] RCURLY
param ::= ID [ HAS expr ]

// Note that the rules for expr_op.* use a special case of Grammar-Kit. Left
// recursion would not be possible otherwise.
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://intellij-support.jetbrains.com/hc/en-us/community/posts/360001258300-What-s-the-alternative-to-left-recursion-in-GrammarKit-#community_comment_360000201199
;{ extends("expr_op_.*")=expr_op }
expr_op ::=
    expr_op_implication
  | expr_op_or
  | expr_op_and
  | group_eq
  | group_cmp
  | expr_op_update
  | expr_op_not
  | group_add
  | group_mul
  | expr_op_concat
  | expr_op_has
  | expr_op_neg
  | expr_op_base
private group_eq ::= expr_op_eq | expr_op_ne
private group_cmp ::= expr_op_lt | expr_op_le | expr_op_gt | expr_op_ge
private group_add ::= expr_op_plus | expr_op_minus
private group_mul ::= expr_op_mul | expr_op_div

expr_op_implication ::= expr_op IMPL expr_op
expr_op_or ::= expr_op OR expr_op
expr_op_and ::= expr_op AND expr_op
expr_op_eq ::= expr_op EQ expr_op
expr_op_ne ::= expr_op NEQ expr_op
expr_op_lt ::= expr_op LT expr_op
expr_op_le ::= expr_op LEQ expr_op
expr_op_gt ::= expr_op GT expr_op
expr_op_ge ::= expr_op GEQ expr_op
expr_op_update ::= expr_op UPDATE expr_op { rightAssociative=true }
expr_op_not ::= NOT expr_op
expr_op_plus ::= expr_op PLUS expr_op
expr_op_minus ::= expr_op MINUS expr_op
expr_op_mul ::= expr_op TIMES expr_op
expr_op_div ::= expr_op DIVIDE expr_op
expr_op_concat ::= expr_op CONCAT expr_op { rightAssociative=true }
expr_op_has ::= expr_op HAS attr_path
expr_op_neg ::= MINUS expr_op
expr_op_base ::= expr_app | expr_select_or_legacy

// Grammar-Kit cannot handle "expr_app ::= expr_app expr_select_or_legacy" or
// equivalent rules. As a workaround, we use this rule which will only create
// one AST node for a series of function calls.
expr_app ::= expr_select_or_legacy expr_select_or_legacy +

;{ extends("expr_select|legacy_app_or")=expr_select_or_legacy }
expr_select_or_legacy ::= legacy_app_or | expr_select
expr_select ::= expr_simple [ DOT attr_path [ OR_KW expr_select_or_legacy ]]
legacy_app_or ::= expr_simple OR_KW

;{ extends("identifier|literal|string|parens|set|list|legacy_let")=expr_simple }
expr_simple ::=
    identifier
  | literal
  | string
  | parens
  | set
  | list
  | legacy_let
identifier ::= ID
literal ::= INT | FLOAT | PATH | HPATH | SPATH | URI
parens ::= LPAREN expr RPAREN
set ::= [ REC ] LCURLY bind* RCURLY
list ::= LBRAC expr_select_or_legacy* RBRAC
legacy_let ::= LET LCURLY bind* RCURLY

;{ extends(".*_string")="string" }
string ::= std_string | ind_string
std_string ::= STRING_OPEN string_part* STRING_CLOSE
ind_string ::= IND_STRING_OPEN string_part* IND_STRING_CLOSE
;{ extends("string_literal_part|string_expr_part")=string_part }
string_part ::= string_literal_part | string_expr_part
string_literal_part ::= STR | IND_STR
string_expr_part ::= DOLLAR_CURLY expr RCURLY

;{ extends("bind_.*")=bind }
bind ::= bind_attr | bind_inherit
bind_attr ::= attr_path ASSIGN expr SEMI
bind_inherit ::= INHERIT [ LPAREN expr RPAREN ] attr* SEMI

;{ extends(".*_attr")=attr }
attr ::= std_attr | string_attr
std_attr ::= ID | OR_KW
string_attr ::= std_string | DOLLAR_CURLY expr RCURLY

attr_path ::= attr ( DOT attr )*
